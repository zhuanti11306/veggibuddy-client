function t(t){const e={value:null,proxy:null,set(t){this.value=t},get(){if(null===this.value)throw new Error(t);return this.value}};return e.proxy=new Proxy(e,{get(t,e){const r=t.get(),i=Reflect.get(r,e);return i instanceof Function?(...t)=>i.apply(r,t):i},set(t,e,r){const i=t.get();return Reflect.set(i,e,r)}}),e}class e{buffer;dataView;synchronize;gpu=null;constructor(t,e=!0){this.buffer=t,this.dataView=new DataView(this.buffer),this.synchronize=e}getGPUBuffer(t){if(this.gpu){if(this.gpu.device===t)return this.gpu.buffer;throw new Error("GPUBuffer is already created for another device.")}const e=t.createBuffer({size:this.buffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return this.gpu={device:t,buffer:e},t.queue.writeBuffer(e,0,this.buffer,0,this.buffer.byteLength),e}updateGPUBuffer(t,e){if(!this.synchronize||!this.gpu)return e;const{device:r,buffer:i}=this.gpu;return r.queue.writeBuffer(i,t,this.buffer,t,e),e}set(t,e){return e.writeStructedView(this,t)}setInteger(t,e){return this.setSignedInteger(t,e)}setFloatNumber(t,e){return this.dataView.setFloat32(t,e,!0),this.updateGPUBuffer(t,Float32Array.BYTES_PER_ELEMENT)}setSignedInteger(t,e){return this.dataView.setInt32(t,e,!0),this.updateGPUBuffer(t,Int32Array.BYTES_PER_ELEMENT)}setUnsignedInteger(t,e){return this.dataView.setUint32(t,e,!0),this.updateGPUBuffer(t,Uint32Array.BYTES_PER_ELEMENT)}append(t,e){const r=e.getAlignment(),i=(r-t%r)%r,s=e.writeStructedView(this,t+i);return i+this.updateGPUBuffer(t+i,s)}appendInteger(t,e){const r=Int32Array.BYTES_PER_ELEMENT,i=(r-t%r)%r;return i+this.setInteger(t+i,e)}appendFloat(t,e){const r=Float32Array.BYTES_PER_ELEMENT,i=(r-t%r)%r;return i+this.setFloatNumber(t+i,e)}appendSignedInteger(t,e){const r=Int32Array.BYTES_PER_ELEMENT,i=(r-t%r)%r;return i+this.setSignedInteger(t+i,e)}appendUnsignedInteger(t,e){const r=Uint32Array.BYTES_PER_ELEMENT,i=(r-t%r)%r;return i+this.setUnsignedInteger(t+i,e)}getBuffer(){return this.buffer}}let r=class t{dimension;data;constructor(t){this.dimension=t.length,this.data=new Float32Array(this.dimension),this.data.set(t)}get x(){return this.get(0)}get y(){return this.get(1)}get z(){return this.get(2)}get w(){return this.get(3)}set x(t){this.set(0,t)}set y(t){this.set(1,t)}set z(t){this.set(2,t)}set w(t){this.set(3,t)}get r(){return this.get(0)}get g(){return this.get(1)}get b(){return this.get(2)}get a(){return this.get(3)}set r(t){this.set(0,t)}set g(t){this.set(1,t)}set b(t){this.set(2,t)}set a(t){this.set(3,t)}get(t){if(t>=this.dimension)throw new RangeError("Index Out Of Range");return this.data[t]}set(t,e){if(t>=this.dimension)throw new RangeError("Index Out Of Range");this.data[t]=e}length(){return Math.hypot(...this.data)}scaleWith(t){for(let e=0;e<this.data.length;e++)this.data[e]*=t;return this}normalize(){const t=this.length();for(let e=0;e<this.data.length;e++)this.data[e]/=t;return this}clone(){return new t(this.data.slice())}static add(e,r){return new t(e.data.map(((t,e)=>t+r.data[e])))}static subtract(e,r){return new t(e.data.map(((t,e)=>t-r.data[e])))}static dot(t,e){return t.data.reduce(((t,r,i)=>t+r*e.data[i]),0)}static cross(e,r){if(3!==e.dimension||3!==r.dimension)throw new RangeError("Dimension Mismatch");return new t([e.y*r.z-e.z*r.y,e.z*r.x-e.x*r.z,e.x*r.y-e.y*r.x])}static transform(e,r){if(e.dimension!==r.column)throw new RangeError("Dimension Mismatch");const i=new Float32Array(r.row);for(let t=0;t<r.row;t++)i[t]=r.getRow(t).reduce(((t,r,i)=>t+r*e.get(i)),0);return new t(i)}static distance(t,e){return Math.hypot(...t.data.map(((t,r)=>t-e.data[r])))}static isEqual(t,e){if(t.dimension!==e.dimension)return!1;for(let r=0;r<t.dimension;r++)if(t.get(r)!==e.get(r))return!1;return!0}getAlignment(){return this.dimension>2?4*Float32Array.BYTES_PER_ELEMENT:2*Float32Array.BYTES_PER_ELEMENT}getSize(){return this.data.length*Float32Array.BYTES_PER_ELEMENT}writeStructedView(t,e){for(let r=0;r<this.data.length;r++)t.setFloatNumber(e+r*Float32Array.BYTES_PER_ELEMENT,this.data[r]);return this.data.length*Float32Array.BYTES_PER_ELEMENT}};function i(...t){return new r(t)}function s(t){return new r(new Float32Array(t))}let n=class t{dimension;data;constructor(t,e,r){if(r.length!==t*e)throw new RangeError("Data length mismatch.");this.dimension=[t,e],this.data=new Float32Array(r.length),this.data.set(r)}get column(){return this.dimension[0]}get row(){return this.dimension[1]}get(t,e){if(t>=this.column||e>=this.row)throw new RangeError("Index Out Of Range");return this.data[t*this.row+e]}set(t,e,r){if(t>=this.column||e>=this.row)throw new RangeError("Index Out Of Range");this.data[t*this.row+e]=r}getRow(t){if(t>=this.row)throw new RangeError("Index Out Of Range");const e=Array(this.column);for(let r=0;r<this.column;r++)e[r]=this.data[r*this.row+t];return e}getColumn(t){if(t>=this.column)throw new RangeError("Index Out Of Range");const e=Array(this.row);for(let r=0;r<this.row;r++)e[r]=this.data[t*this.row+r];return e}getRowVector(t){return new r(this.getRow(t))}getColumnVector(t){return new r(this.getRow(t))}clone(){return new t(this.column,this.row,this.data)}static add(e,r){if(e.column!==r.column||e.row!==r.row)throw new Error("Matrix size mismatch.");return new t(e.column,e.row,e.data.map(((t,e)=>t+r.data[e])))}static subtract(e,r){if(e.column!==r.column||e.row!==r.row)throw new Error("Matrix size mismatch.");return new t(e.column,e.row,e.data.map(((t,e)=>t-r.data[e])))}static scale(e,r){return new t(e.column,e.row,e.data.map((t=>t*r)))}static multiply(e,r){if(e.column!==r.row)throw new Error("Matrix size mismatch.");const i=r.column,s=e.row,n=e.column,a=new Float32Array(i*s);for(let t=0;t<s;t++)for(let o=0;o<i;o++){let i=0;for(let s=0;s<n;s++)i+=e.get(s,t)*r.get(o,s);a[o*s+t]=i}return new t(i,s,a)}static transpose(e){const r=new Float32Array(e.row*e.column);for(let t=0;t<e.row;t++)for(let i=0;i<e.column;i++)r[t*e.column+i]=e.get(i,t);return new t(e.row,e.column,r)}static identity(e){const r=new Float32Array(e*e);for(let t=0;t<e;t++)r[t*e+t]=1;return new t(e,e,r)}static determinant(e){if(e.column!==e.row)throw new Error("Matrix is not square.");if(2===e.column)return e.get(0,0)*e.get(1,1)-e.get(0,1)*e.get(1,0);console.log(e);let r=0;for(let i=0;i<e.column;i++)r+=(i%2==0?1:-1)*e.get(0,i)*t.determinant(t.subMatrix(e,0,i));return r}static adjugate(e){if(e.column!==e.row)throw new Error("Matrix is not square.");if(2===e.column)return new t(e.column,e.row,new Float32Array([e.get(1,1),-e.get(0,1),-e.get(1,0),e.get(0,0)]));const r=new Float32Array(e.column*e.row);for(let i=0;i<e.row;i++)for(let s=0;s<e.column;s++){const n=(i+s)%2*-2+1;r[i*e.column+s]=n*t.determinant(t.subMatrix(e,i,s))}return new t(e.column,e.row,r)}static subMatrix(e,r,i){if(2==e.row||2==e.column)throw new Error("Submatrix dimension too small");const s=e.row-1,n=e.column-1,a=[];for(let t=0;t<e.row;t++)if(t!==r)for(let r=0;r<e.column;r++)r!==i&&a.push(e.get(t,r));return new t(n,s,a)}static inverse(e){if(e.column!==e.row)throw new Error("Matrix is not square.");const r=t.determinant(e);if(0===r)throw new Error("Matrix is singular.");const i=t.adjugate(e);return t.scale(i,1/r)}static isEqual(t,e){if(t.column!==e.column||t.row!==e.row)return!1;for(let r=0;r<t.data.length;r++)if(t.data[r]!==e.data[r])return!1;return!0}getAlignment(){return this.column>2?4*Float32Array.BYTES_PER_ELEMENT:2*Float32Array.BYTES_PER_ELEMENT}getSize(){return(this.column>2?4:2)*this.row*Float32Array.BYTES_PER_ELEMENT}writeStructedView(t,e){for(let r=0;r<this.data.length;r++)t.setFloatNumber(e+r*Float32Array.BYTES_PER_ELEMENT,this.data[r]);return this.data.length*Float32Array.BYTES_PER_ELEMENT}};function a(t,e,r){return new n(t,e,r)}function o(t,e){return new n(t,e,new Float32Array(t*e))}function u(t){return n.identity(t)}var h=(t=>(t.int="int",t.uint="uint",t.float="float",t))(h||{}),c=(t=>(t.vec2="vec2",t.vec3="vec3",t.vec4="vec4",t))(c||{}),l=(t=>(t.mat2x2="mat2x2",t.mat2x3="mat2x3",t.mat2x4="mat2x4",t.mat3x2="mat3x2",t.mat3x3="mat3x3",t.mat3x4="mat3x4",t.mat4x2="mat4x2",t.mat4x3="mat4x3",t.mat4x4="mat4x4",t))(l||{});class d{descriptor;data;alignment;size;offsets;constructor(t,e){this.descriptor=t,this.data=e??d.getDefaultValue(t),this.alignment=0,this.size=0,this.offsets={};for(const i in this.descriptor){const t=this.data[i];let e=0,s=0;"number"==typeof t?(e=4,s=4):(t instanceof r||t instanceof n||t instanceof d)&&(e=t.getAlignment(),s=t.getSize()),this.size+=(e-this.size%e)%e,this.offsets[i]=this.size,this.size+=s,this.alignment=Math.max(this.alignment,e)}this.size=Math.ceil(this.size/this.alignment)*this.alignment}get(t){return this.data[t]}set(t,e){const i=this.data[t];switch(this.descriptor[t]){case h.int:case h.uint:case h.float:if(i==e)return;break;case c.vec2:case c.vec3:case c.vec4:if(r.isEqual(i,e))return;break;case l.mat2x2:case l.mat2x3:case l.mat2x4:case l.mat3x2:case l.mat3x3:case l.mat3x4:case l.mat4x2:case l.mat4x3:case l.mat4x4:if(n.isEqual(i,e))return}this.data[t]=e}getAlignment(){return this.alignment}getSize(){return this.size}writeStructedView(t,e){for(const r in this.descriptor){const i=this.offsets[r]+e;this.writeProperty(t,i,r)}return this.size}writeProperty(t,e,i){const s=this.descriptor[i],a=this.data[i];if("number"==typeof a)switch(s){case h.int:t.setSignedInteger(e,a);break;case h.uint:t.setUnsignedInteger(e,a);break;case h.float:t.setFloatNumber(e,a);break;default:throw new Error("Invalid Scalar Type")}else(a instanceof r||a instanceof n||a instanceof d)&&a.writeStructedView(t,e)}getSubStruct(t){const e={};for(const r of t)e[r]=this.descriptor[r];return new d(e,this.data)}getClonedStruct(t,e){if(void 0===e)return new d(this.descriptor,t?this.deepClone(this.data):this.data);const r={},i={};for(const s of e)r[s]=this.descriptor[s],i[s]=t?this.deepCloneValue(this.data[s]):this.data[s];return new d(r,i)}deepCloneValue(t){if("number"==typeof t)return t;if(t instanceof r)return t.clone();if(t instanceof n)return t.clone();if(t instanceof d)return t.getClonedStruct(!0);throw new Error("Unsupported type for deep clone")}deepClone(t){const e={};for(const r in t)e[r]=this.deepCloneValue(t[r]);return e}static getDefaultValue(t){const e={};for(const r in t)switch(t[r]){case h.int:case h.uint:case h.float:e[r]=0;break;case c.vec2:e[r]=s(2);break;case c.vec3:e[r]=s(3);break;case c.vec4:e[r]=s(4);break;case l.mat2x2:e[r]=o(2,2);break;case l.mat2x3:e[r]=o(2,3);break;case l.mat2x4:e[r]=o(2,4);break;case l.mat3x2:e[r]=o(3,2);break;case l.mat3x3:e[r]=o(3,3);break;case l.mat3x4:e[r]=o(3,4);break;case l.mat4x2:e[r]=o(4,2);break;case l.mat4x3:e[r]=o(4,3);break;case l.mat4x4:e[r]=o(4,4);break;default:if("object"!=typeof t[r])throw new Error("Invalid type in descriptor");e[r]=this.getDefaultValue(t[r])}return e}}class f extends d{label;view;constructor(t,r,i,s=!0){super(r,i),this.label=t,this.view=new e(new ArrayBuffer(this.getSize()),s)}set(t,e){super.set(t,e);const r=this.offsets[t];this.writeProperty(this.view,r,t)}getGPUBuffer(t){return this.view.getGPUBuffer(t)}}class g{static registeredLayouts=new Map;static emptyLayout=g.registerLayout("empty",[]);static registerLayout(t,e){if(this.registeredLayouts.has(t))throw new Error(`BindGroupLayout with label "${t}" already exists.`);const r=new g(t,{entries:e});return this.registeredLayouts.set(t,r),r}static getLayout(t){const e=this.registeredLayouts.get(t);if(!e)throw new Error(`BindGroupLayout with label "${t}" not found.`);return e}static unregisterLayout(t){if(!this.registeredLayouts.has(t))throw new Error(`BindGroupLayout with label "${t}" not found.`);this.registeredLayouts.delete(t)}static getPipelineLayout(t,e){const r=[];for(const i of e){let e;e=null===i?g.emptyLayout.getGPUBindGroupLayout(t):"string"==typeof i?g.getLayout(i).getGPUBindGroupLayout(t):i instanceof g?i.getGPUBindGroupLayout(t):g.getGPUBindGroupLayout(t,null,i),r.push(e)}return t.createPipelineLayout({bindGroupLayouts:r})}label;descriptor;layout=null;constructor(t,e){this.label=t,this.descriptor=e}getGPUBindGroupLayout(t){return this.layout?this.layout:this.layout=g.getGPUBindGroupLayout(t,this.label,this.descriptor)}getEntryBindings(){const t={};return this.descriptor.entries.forEach(((e,r)=>{t[e.key]=r})),t}static getGPUBindGroupLayout(t,e,r){const i=[];for(const s of r.entries){const{category:t,visibility:e}=s;switch(t){case"buffer":i.push({binding:i.length,visibility:e,buffer:s});break;case"sampler":i.push({binding:i.length,visibility:e,sampler:s});break;case"texture":i.push({binding:i.length,visibility:e,texture:s});break;case"storage-texture":i.push({binding:i.length,visibility:e,storageTexture:s});break;case"read-only-texture":i.push({binding:i.length,visibility:e,externalTexture:s})}}return t.createBindGroupLayout({label:e??void 0,entries:i})}createBindGroup(t){return new p(this.label,{layout:this,entries:t})}}class p{label;descriptor;layout;gpuLayout=null;gpuBindGroup=null;constructor(t,e){this.label=t,this.descriptor=e,"string"==typeof e.layout?this.layout=g.getLayout(e.layout):e.layout instanceof g?this.layout=e.layout:this.layout=new g(t,e.layout)}getGPUBindGroup(t){if(this.gpuBindGroup)return this.gpuBindGroup;console.log("[DBG] Creating BindGroup:",this.label),this.gpuLayout=this.layout.getGPUBindGroupLayout(t);const r=this.layout.getEntryBindings(),i=[];for(const[s,n]of Object.entries(this.descriptor.entries)){const a=r[s];let o;switch(this.layout.descriptor.entries[a].category){case"buffer":let r,i,s=n;if("buffer"in s&&({buffer:s,offset:r,size:i}=s),s instanceof e)s=s.getGPUBuffer(t);else if(s instanceof f)s=s.getGPUBuffer(t);else if(!(s instanceof GPUBuffer))throw new Error("Invalid buffer type.");o={buffer:s,offset:r,size:i};break;case"sampler":o=n.getGPUSampler(t);break;case"texture":case"storage-texture":case"read-only-texture":o=n.getGPUTextureView(t);break;default:o=n}i.push({binding:a,resource:o})}return this.gpuBindGroup=t.createBindGroup({label:this.label,layout:this.gpuLayout,entries:i}),this.gpuBindGroup}destroy(){this.gpuBindGroup=null,console.log("[DBG] Destroying BindGroup:",this.label)}[Symbol.dispose](){this.gpuBindGroup=null,this.gpuLayout=null}}const x={isInitialized:!1,preferredFormat:null,adapterProxy:t("WebGPU not initialized"),deviceProxy:t("WebGPU not initialized"),canvasProxy:t("WebGPU not initialized"),contextProxy:t("WebGPU not initialized")};const{proxy:y}=x.adapterProxy,{proxy:w}=x.deviceProxy,{proxy:m}=x.canvasProxy,{proxy:E}=x.contextProxy;function P(){return x.isInitialized}function b(){if(!x.isInitialized)throw new Error("WebGPU not initialized");return x.preferredFormat}function S(){if(!x.isInitialized)throw new Error("WebGPU not initialized");return E.getCurrentTexture().createView()}class B{buffer;dataView;synchronize;gpu=null;constructor(t,e=!0){this.buffer=t,this.dataView=new DataView(this.buffer),this.synchronize=e}get byteLength(){return this.buffer.byteLength}getGPUBuffer(t){if(this.gpu){if(this.gpu.device===t)return this.gpu.buffer;throw new Error("GPUBuffer is already created for another device.")}const e=t.createBuffer({size:this.buffer.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return this.gpu={device:t,buffer:e},t.queue.writeBuffer(e,0,this.buffer,0,this.buffer.byteLength),e}updateGPUBuffer(t,e){if(!this.synchronize||!this.gpu)return e;const{device:r,buffer:i}=this.gpu;return r.queue.writeBuffer(i,t,this.buffer,t,e),e}setByte(t,e){return this.setSignedByte(t,e)}setByteVector(t,e){return this.setSignedByteVector(t,e)}setSignedByte(t,e){return this.dataView.setInt8(t,e),this.updateGPUBuffer(t,Int8Array.BYTES_PER_ELEMENT)}setSignedByteVector(t,e){return this.setSignedByteArray(t,e.data)}setUnsignedByte(t,e){return this.dataView.setUint8(t,e),this.updateGPUBuffer(t,Uint8Array.BYTES_PER_ELEMENT)}setUnsignedByteVector(t,e){return this.setUnsignedByteArray(t,e.data)}setShortInteger(t,e){return this.setSignedShortInteger(t,e)}setShortIntegerVector(t,e){return this.setSignedShortIntegerVector(t,e)}setSignedShortInteger(t,e){return this.dataView.setInt16(t,e,!0),this.updateGPUBuffer(t,Int16Array.BYTES_PER_ELEMENT)}setSignedShortIntegerVector(t,e){return this.setSignedShortIntegerArray(t,e.data)}setUnsignedShortInteger(t,e){return this.dataView.setUint16(t,e,!0),this.updateGPUBuffer(t,Uint16Array.BYTES_PER_ELEMENT)}setUnsignedShortIntegerVector(t,e){return this.setUnsignedShortIntegerArray(t,e.data)}setFloatNumber(t,e){return this.setSinglePrecision(t,e)}setFloatNumberVector(t,e){return this.setSinglePrecisionVector(t,e)}setSinglePrecision(t,e){return this.dataView.setFloat32(t,e,!0),this.updateGPUBuffer(t,Float32Array.BYTES_PER_ELEMENT)}setSinglePrecisionVector(t,e){return this.setFloatNumberArray(t,e.data)}setHalfPrecision(t,e){throw new Error("Not implemented")}setHalfPrecisionVector(t,e){throw new Error("Not implemented")}setInteger(t,e){return this.setSignedInteger(t,e)}setIntegerVector(t,e){return this.setSignedIntegerVector(t,e)}setSignedInteger(t,e){return this.dataView.setInt32(t,e,!0),this.updateGPUBuffer(t,Int32Array.BYTES_PER_ELEMENT)}setSignedIntegerVector(t,e){return this.setSignedIntegerArray(t,e.data)}setUnsignedInteger(t,e){return this.dataView.setUint32(t,e,!0),this.updateGPUBuffer(t,Uint32Array.BYTES_PER_ELEMENT)}setUnsignedIntegerVector(t,e){return this.setUnsignedIntegerArray(t,e.data)}setNormalizedSignedByte(t,e){return this.dataView.setInt8(t,(255*e-1)/2),this.updateGPUBuffer(t,Int8Array.BYTES_PER_ELEMENT)}setNormalizedSignedByteVector(t,e){return this.setNormalizedSignedByteArray(t,e.data)}setNormalizedUnsignedByte(t,e){return this.dataView.setUint8(t,255*e),this.updateGPUBuffer(t,Uint8Array.BYTES_PER_ELEMENT)}setNormalizedUnsignedByteVector(t,e){return this.setNormalizedUnsignedByteArray(t,e.data)}setNormalizedSignedShortInteger(t,e){return this.dataView.setInt16(t,(65535*e-1)/2,!0),this.updateGPUBuffer(t,Int16Array.BYTES_PER_ELEMENT)}setNormalizedSignedShortIntegerVector(t,e){return this.setNormalizedSignedShortIntegerArray(t,e.data)}setNormalizedUnsignedShortInteger(t,e){return this.dataView.setUint16(t,65535*e,!0),this.updateGPUBuffer(t,Uint16Array.BYTES_PER_ELEMENT)}setNormalizedUnsignedShortIntegerVector(t,e){return this.setNormalizedUnsignedShortIntegerArray(t,e.data)}setUnsignedByteArray(t,e){return new Uint8Array(this.buffer,t,e.length).set(e),this.updateGPUBuffer(t,Uint8Array.BYTES_PER_ELEMENT*e.length)}setSignedByteArray(t,e){return new Int8Array(this.buffer,t,e.length).set(e),this.updateGPUBuffer(t,Int8Array.BYTES_PER_ELEMENT*e.length)}setUnsignedShortIntegerArray(t,e){return new Uint16Array(this.buffer,t,e.length).set(e),this.updateGPUBuffer(t,Uint16Array.BYTES_PER_ELEMENT*e.length)}setSignedShortIntegerArray(t,e){return new Int16Array(this.buffer,t,e.length).set(e),this.updateGPUBuffer(t,Int16Array.BYTES_PER_ELEMENT*e.length)}setUnsignedIntegerArray(t,e){return new Uint32Array(this.buffer,t,e.length).set(e),this.updateGPUBuffer(t,Uint32Array.BYTES_PER_ELEMENT*e.length)}setSignedIntegerArray(t,e){return new Int32Array(this.buffer,t,e.length).set(e),this.updateGPUBuffer(t,Int32Array.BYTES_PER_ELEMENT*e.length)}setFloatNumberArray(t,e){return new Float32Array(this.buffer,t,e.length).set(e),this.updateGPUBuffer(t,Float32Array.BYTES_PER_ELEMENT*e.length)}setNormalizedUnsignedByteArray(t,e){const r=new Uint8Array(this.buffer,t,e.length);for(let i=0;i<e.length;i++)r[i]=255*e[i];return this.updateGPUBuffer(t,Uint8Array.BYTES_PER_ELEMENT*e.length)}setNormalizedSignedByteArray(t,e){const r=new Int8Array(this.buffer,t,e.length);for(let i=0;i<e.length;i++)r[i]=(255*e[i]-1)/2;return this.updateGPUBuffer(t,Int8Array.BYTES_PER_ELEMENT*e.length)}setNormalizedUnsignedShortIntegerArray(t,e){const r=new Uint16Array(this.buffer,t,e.length);for(let i=0;i<e.length;i++)r[i]=65535*e[i];return this.updateGPUBuffer(t,Uint16Array.BYTES_PER_ELEMENT*e.length)}setNormalizedSignedShortIntegerArray(t,e){const r=new Int16Array(this.buffer,t,e.length);for(let i=0;i<e.length;i++)r[i]=(65535*e[i]-1)/2;return this.updateGPUBuffer(t,Int16Array.BYTES_PER_ELEMENT*e.length)}setNormalizedUnsignedIntegerArray(t,e){const r=new Uint32Array(this.buffer,t,e.length);for(let i=0;i<e.length;i++)r[i]=4294967295*e[i];return this.updateGPUBuffer(t,Uint32Array.BYTES_PER_ELEMENT*e.length)}setNormalizedSignedIntegerArray(t,e){const r=new Int32Array(this.buffer,t,e.length);for(let i=0;i<e.length;i++)r[i]=(4294967295*e[i]-1)/2;return this.updateGPUBuffer(t,Int32Array.BYTES_PER_ELEMENT*e.length)}}var U=(t=>(t.sint32="sint32",t.uint32="uint32",t.float32="float32",t.sint="sint32",t.uint="uint32",t.float="float32",t.int="sint32",t))(U||{}),A=(t=>(t.uint8x2="uint8x2",t.uint8x4="uint8x4",t.sint8x2="sint8x2",t.sint8x4="sint8x4",t.unorm8x2="unorm8x2",t.unorm8x4="unorm8x4",t.snorm8x2="snorm8x2",t.snorm8x4="snorm8x4",t.uint16x2="uint16x2",t.uint16x4="uint16x4",t.sint16x2="sint16x2",t.sint16x4="sint16x4",t.unorm16x2="unorm16x2",t.unorm16x4="unorm16x4",t.snorm16x2="snorm16x2",t.snorm16x4="snorm16x4",t.float16x2="float16x2",t.float16x4="float16x4",t.uint32x2="uint32x2",t.uint32x3="uint32x3",t.uint32x4="uint32x4",t.sint32x2="sint32x2",t.sint32x3="sint32x3",t.sint32x4="sint32x4",t.float32x2="float32x2",t.float32x3="float32x3",t.float32x4="float32x4",t.uintx2="uint32x2",t.uintx3="uint32x3",t.uintx4="uint32x4",t.sintx2="sint32x2",t.sintx3="sint32x3",t.sintx4="sint32x4",t.floatx2="float32x2",t.floatx3="float32x3",t.floatx4="float32x4",t.intx2="sint32x2",t.intx3="sint32x3",t.intx4="sint32x4",t))(A||{}),T=(t=>(t.uint16="uint16",t.uint32="uint32",t))(T||{});class v{static registeredVertexArrays=new Map;static createRegisteredVertexArray(t,e,r=[],i){if(v.registeredVertexArrays.has(t))throw new Error(`VertexArray with name ${t} is already registered.`);const s=new v(t,e,r,i);return v.registeredVertexArrays.set(t,s),s}static registerVertexArray(t,e){if(v.registeredVertexArrays.has(t))throw new Error(`VertexArray with name ${t} is already registered.`);v.registeredVertexArrays.set(t,e)}static getVertexArray(t){const e=v.registeredVertexArrays.get(t);if(!e)throw new Error(`VertexArray with name ${t} is not registered.`);return e}descriptor;data;indices=null;label;mode="vertex";get vertexCount(){return this.data.length}registeredViews=new Map;constructor(t,e,r=[],i){if(this.label=t,this.descriptor=e,this.data="number"==typeof r?Array(r).fill(v.getDefaultVertexData(e)):Array.from(r),i){const t=Math.max(...i);if(t>=this.vertexCount)throw new RangeError("Index Out Of Range");const e=t>65535?4:2,r=new ArrayBuffer(e*i.length),{view:s}=this.indices={view:new B(r),type:null};e<=2?(s.setUnsignedShortIntegerArray(0,i),this.indices.type=T.uint16):e<=4&&(s.setUnsignedIntegerArray(0,i),this.indices.type=T.uint32)}}get(t,e=!1){if(t<0||t>=this.vertexCount)throw new RangeError("Index Out Of Range");const i=this.data[t];if(!e)return i;const s={};for(const n in this.descriptor){const t=i[n];"number"==typeof t?s[n]=t:t instanceof r&&(s[n]=t.clone())}return s}set(t,e){if(t<0||t>=this.vertexCount)throw new RangeError("Index Out Of Range");const r=this.data[t];this.data[t]=e;const i=[];for(const s in this.descriptor)r[s]!==e[s]&&i.push(s);for(const{vertices:s}of this.registeredViews.values())for(const{attributes:e,stride:r,view:n}of s){const s=t*r,a=this.data[t];for(const t of i){const r=e[t];if(!r)continue;const i=s+r.offset,o=a[t],u=this.descriptor[t];this.writeProperty(n,i,u,o)}}}getBufferLayout(...t){0===t.length&&(t=[Array.from(Object.keys(this.descriptor))]);const e={count:this.vertexCount,vertices:[],stepMode:this.mode};let r=0;for(const i of t){const{stride:t,attributes:s,nextLocation:n}=v.getStrideAndAttributes(this.descriptor,r,i);r=n;const a=new ArrayBuffer(this.vertexCount*t),o=new B(a),u={view:o,attributes:s,stride:t};this.writeVertexArray(o,t,s),e.vertices.push(u)}return this.indices&&(e.indices=this.indices),e}getRegisteredLayout(t,...e){if(this.registeredViews.has(t))return this.registeredViews.get(t);const r=e.length?this.getBufferLayout(e):this.getBufferLayout();return this.registeredViews.set(t,r),r}unregisterView(t){return this.registeredViews.delete(t)}writeVertexArray(t,e,r){for(let i=0;i<this.vertexCount;i++){const s=i*e,n=this.data[i];for(const e in this.descriptor){const i=r[e];if(!i)continue;const a=s+i.offset,o=n[e],u=this.descriptor[e];this.writeProperty(t,a,u,o)}}return t}writeProperty(t,e,r,i){switch(r){case void 0:return 0;case U.sint:return t.setSignedInteger(e,i);case U.uint:return t.setUnsignedInteger(e,i);case U.float:return t.setFloatNumber(e,i);case A.sint8x2:case A.sint8x4:return t.setSignedByteVector(e,i);case A.uint8x2:case A.uint8x4:return t.setUnsignedByteVector(e,i);case A.sint16x2:case A.sint16x4:return t.setSignedShortIntegerVector(e,i);case A.uint16x2:case A.uint16x4:return t.setUnsignedShortIntegerVector(e,i);case A.sint32x2:case A.sint32x3:case A.sint32x4:return t.setSignedIntegerVector(e,i);case A.uint32x2:case A.uint32x3:case A.uint32x4:return t.setUnsignedIntegerVector(e,i);case A.float16x2:case A.float16x4:return t.setHalfPrecisionVector(e,i);case A.float32x2:case A.float32x4:return t.setSinglePrecisionVector(e,i);case A.snorm8x2:case A.snorm8x4:return t.setNormalizedSignedByteVector(e,i);case A.unorm8x2:case A.unorm8x4:return t.setNormalizedUnsignedByteVector(e,i);case A.snorm16x2:case A.snorm16x4:return t.setNormalizedSignedShortIntegerVector(e,i);case A.unorm16x2:case A.unorm16x4:return t.setNormalizedUnsignedShortIntegerVector(e,i);default:throw new Error("Invalid Data Type")}}static getStrideAndAttributes(t,e=0,r){const i={};let s=0,n=e;for(const[a,o]of Object.entries(t))if((!r||r.includes(a))&&void 0!==o)switch(i[a]={shaderLocation:n++,offset:s,format:o},o){case A.sint8x2:case A.uint8x2:case A.snorm8x2:case A.unorm8x2:s+=2;break;case A.sint8x4:case A.uint8x4:case A.snorm8x4:case A.unorm8x4:case A.sint16x2:case A.uint16x2:case A.snorm16x2:case A.unorm16x2:case A.float16x2:case U.sint32:case U.uint32:case U.float:s+=4;break;case A.sint16x4:case A.uint16x4:case A.snorm16x4:case A.unorm16x4:case A.float16x4:case A.sint32x2:case A.uint32x2:case A.float32x2:s+=8;break;case A.sint32x3:case A.uint32x3:case A.float32x3:s+=12;break;case A.sint32x4:case A.uint32x4:case A.float32x4:s+=16}return{stride:s,attributes:i,nextLocation:n}}static getDefaultVertexData(t){const e={};for(const r in t)switch(t[r]){case U.sint:case U.uint:case U.float:e[r]=0;break;case A.sint8x2:case A.sint16x2:case A.sint32x2:case A.uint8x2:case A.uint16x2:case A.uint32x2:case A.snorm8x2:case A.snorm16x2:case A.unorm8x2:case A.unorm16x2:case A.float16x2:case A.float32x2:e[r]=i(0,0);break;case A.sint32x3:case A.uint32x3:case A.float32x3:e[r]=i(0,0,0);break;case A.sint8x4:case A.sint16x4:case A.sint32x4:case A.uint8x4:case A.uint16x4:case A.uint32x4:case A.snorm8x4:case A.snorm16x4:case A.unorm8x4:case A.unorm16x4:case A.float16x4:case A.float32x4:e[r]=i(0,0,0,0)}return e}}const G={position:A.float32x2};v.createRegisteredVertexArray("quadrilateral",G,[{position:i(-1,-1)},{position:i(1,-1)},{position:i(-1,1)},{position:i(1,-1)},{position:i(1,1)},{position:i(-1,1)}]),v.createRegisteredVertexArray("fullscreen-triangle",G,[{position:i(-1,-1)},{position:i(-1,3)},{position:i(3,-1)}]);class I{items=new Map;headPointer=0n;tailPointer=0n;get length(){return Number(this.tailPointer-this.headPointer)}constructor(t){if(t)for(const e of t)this.push(e)}push(t){this.items.set(this.tailPointer,t),this.tailPointer++}pop(){if(0===this.length)return;this.tailPointer--;const t=this.items.get(this.tailPointer);return this.items.delete(this.tailPointer),t}shift(){if(0===this.length)return;const t=this.items.get(this.headPointer);return this.items.delete(this.headPointer),this.headPointer++,t}unshift(t){this.headPointer--,this.items.set(this.headPointer,t)}peek(){if(0!==this.length)return this.items.get(this.headPointer)}peekTail(){if(0!==this.length)return this.items.get(this.tailPointer-1n)}clear(){this.items.clear(),this.headPointer=0n,this.tailPointer=0n}isEmpty(){return 0===this.length}[Symbol.iterator](){let t=this.headPointer;const e=this.tailPointer,r=this.items;return{next(){if(t<e){const e=r.get(t);return t++,{value:e,done:!1}}return{value:void 0,done:!0}}}}}class L{static destructionQueue=new I;static destroyTextures(){for(;this.destructionQueue.length>0;){const t=this.destructionQueue.pop();t&&t.destroy()}}}class V extends L{static DEFAULT_FORMAT="rgba8unorm";label;descriptor;format;usage;flipY;size;accessDevice=null;gpuTexture=null;gpuTextureView=null;isLoaded=!1;source;loadSource;constructor(t,e){super(),this.label=t,this.descriptor=e;const{size:r,format:i=V.DEFAULT_FORMAT,usage:s=0,source:n}=e;this.size=r,this.format=i,this.usage=s,this.flipY=e.flipY??!1,n instanceof Function?(this.loadSource=n,this.source=null):(this.loadSource=()=>Promise.resolve(n),this.source=n,this.isLoaded=!0)}getSize(){return this.size}setSize(t){this.isLoaded&&this.unload(),this.size.width=t.width,this.size.height=t.height}getSource(){return this.source}setSource(t){this.isLoaded&&this.unload(),"function"==typeof t?(this.loadSource=t,this.source=null):(this.loadSource=()=>Promise.resolve(t),this.source=t,this.isLoaded=!0)}async load(){this.source||(this.source=await this.loadSource(),this.isLoaded=!0,this.writeTexture())}unload(){this.source=null,this.isLoaded=!1,this.destroyGPUTexture()}getGPUTextureView(t){return this.gpuTextureView||(this.gpuTextureView=this.getGPUTexture(t).createView()),this.gpuTextureView}getGPUTexture(t){if(this.accessDevice!==t){if(this.accessDevice)throw new Error(`Texture ${this.label} is already used by another device.`);this.accessDevice=t}if(this.gpuTexture)return this.gpuTexture;const e=t.createTexture({label:this.label,size:this.size,dimension:"2d",format:this.format,usage:this.usage});return this.gpuTexture=e,this.writeTexture(),e}writeTexture(){const t=this.source,e=this.gpuTexture,r=this.accessDevice;if(t&&e&&r)if(t instanceof ArrayBuffer){const i=V.getBytesPerPixel(this.format),s=this.size.width*i,n=256*Math.ceil(s/256);r.queue.writeTexture({texture:e},t,{offset:0,bytesPerRow:n,rowsPerImage:this.size.height},this.size)}else r.queue.copyExternalImageToTexture({source:t,flipY:this.flipY},{texture:e},this.size)}destroyGPUTexture(){this.gpuTexture&&(this.gpuTexture.destroy(),this.gpuTexture=null),this.gpuTextureView&&(this.gpuTextureView=null),this.accessDevice=null,this.isLoaded=!1}static getBytesPerPixel(t){if(t.endsWith("8unorm")||t.endsWith("8snorm")||t.endsWith("8uint")||t.endsWith("8sint"))return t.startsWith("rgba")?4:t.startsWith("rg")?2:1;if(t.endsWith("16float")||t.endsWith("16uint")||t.endsWith("16sint"))return t.startsWith("rgba")?8:t.startsWith("rg")?4:2;if(t.endsWith("32float")||t.endsWith("32uint")||t.endsWith("32sint"))return t.startsWith("rgba")?16:t.startsWith("rg")?8:4;throw new Error(`Unsupported texture format for ArrayBuffer source: ${t}`)}}function M(t,e){const{url:r,size:i,format:s,usage:n=GPUTextureUsage.TEXTURE_BINDING,flipY:a}=e,o={resizeWidth:i[0],resizeHeight:i[1],resizeQuality:"high"};return new V(t,{size:{width:i[0],height:i[1]},format:s,usage:n|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,flipY:a,source:async()=>{const t=await fetch(r).then((t=>t.blob()));return createImageBitmap(t,o)}})}function R(t,e,r){const i={width:e.width,height:e.height},{format:s,usage:n=GPUTextureUsage.TEXTURE_BINDING,flipY:a}={};return new V(t,{size:i,format:s,flipY:a,usage:n|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,source:()=>e})}const _=new class{loop=null;loopId=null;lastStamp=null;configuringStack=[];passQueue=[];run(t){this.lastStamp=null,this.loop=e=>{const r=this.lastStamp?e-this.lastStamp:0;this.lastStamp=e,t(r),L.destroyTextures(),this.render(),this.loopId=requestAnimationFrame(this.loop)},this.loopId=requestAnimationFrame(this.loop)}stop(){null!==this.loopId&&(cancelAnimationFrame(this.loopId),this.loopId=null),this.loop=null,this.lastStamp=null}render(){const t=w.createCommandEncoder();for(const e of this.passQueue){if(!e.renderSteps.length)continue;const r=t.beginRenderPass({label:e.label,colorAttachments:this.getRenderPassColorAttachments(e),depthStencilAttachment:e.depthStencilAttachment}),i=this.getGPUColorTargetStates(e);for(const t of e.renderSteps){r.setPipeline(t.pipeline.getRenderPipeline(w,i));for(let i=0;i<t.pipeline.bindGroupCount;i++){const s=t.bindGroups?.[i]??e.defaultBindGroups?.[i];s&&r.setBindGroup(i,s.getGPUBindGroup(w))}const{count:s,vertices:n,indices:a}="string"==typeof t.buffer?v.getVertexArray(t.buffer).getRegisteredLayout(t.buffer):t.buffer;n.forEach((({view:t},e)=>r.setVertexBuffer(e,t.getGPUBuffer(w),0,t.byteLength))),a?(r.setIndexBuffer(a.view.getGPUBuffer(w),a.type),r.drawIndexed(s)):r.draw(s)}r.end()}w.queue.submit([t.finish()]),this.configuringStack=[],this.passQueue=[]}beginPass(t){this.configuringStack.push({...t,renderSteps:[]})}endPass(){if(0===this.configuringStack.length)throw new Error("No pass is currently configured.");const t=this.configuringStack.pop();this.passQueue.push(t)}currentPass(){return 0===this.configuringStack.length?null:this.configuringStack.at(-1)}draw(t){if(0===this.configuringStack.length)throw new Error("No pass is currently configured.");this.configuringStack[this.configuringStack.length-1].renderSteps.push(t)}getRenderPassColorAttachments(t){if(!t.colorAttachments)return[null];const e=[];for(const r of t.colorAttachments)if("canvas"===r)e.push({view:S(),loadOp:"clear",clearValue:[0,0,0,1],storeOp:"store"});else if(r){const t=r.loadOp??"load",i=r.clearValue??("clear"===t?[0,0,0,1]:void 0),s=r.storeOp??"store";e.push({view:r.view,loadOp:t,clearValue:i,storeOp:s})}else e.push(null);return e}getGPUColorTargetStates(t){if(!t.colorAttachments)return[null];const e=[];for(const r of t.colorAttachments)"canvas"===r?e.push({format:b(),writeMask:GPUColorWrite.ALL}):r?e.push({format:r.format??b(),writeMask:r.writeMask??GPUColorWrite.ALL,blend:r.blendMode??void 0}):e.push(null);return e}},z=_.run.bind(_);_.stop.bind(_),_.render.bind(_);const N=_.beginPass.bind(_),Y=_.endPass.bind(_),F=_.currentPass.bind(_),k=_.draw.bind(_);class C{label;code;gpuShaderModule=null;constructor(t,e){this.label=t,"string"==typeof e?this.code=e:(this.gpuShaderModule=e,this.code="")}getGPUShaderModule(t){return this.gpuShaderModule?this.gpuShaderModule:this.gpuShaderModule=t.createShaderModule({label:this.label,code:this.code})}async getGPUCompilationMessage(){if(!this.gpuShaderModule)throw new Error("GPUShaderModule is not created yet.");return this.gpuShaderModule.getCompilationInfo()}[Symbol.dispose](){this.gpuShaderModule=null}}class O{renderPipeline=null;label;pipelineLayout;bindGroupCount=0;vertexShaderModule;vertexShaderEntryPoint=void 0;fragmentShaderModule;fragmentShaderEntryPoint=void 0;vertexStepMode="vertex";vertexBufferLayout=[];constructor(t,e){this.label=t;const r=e.shader.vertex.module;this.vertexShaderEntryPoint=e.shader.vertex.entryPoint,this.vertexShaderModule=r instanceof C?r:new C(t+" Vertex Shader",r);const i=e.shader.fragment.module;this.fragmentShaderEntryPoint=e.shader.fragment.entryPoint,this.fragmentShaderModule=i instanceof C?i:new C(t+" Fragment Shader",i),this.pipelineLayout=e.layout??"auto",this.bindGroupCount="auto"===this.pipelineLayout?0:this.pipelineLayout.length,this.vertexStepMode=e.vertexStepMode??"vertex";let s=0;for(const n of e.vertex){const{stride:t,attributes:e,nextLocation:r}=v.getStrideAndAttributes(n,s);this.vertexBufferLayout.push({stride:t,attributes:e}),s=r}}getRenderPipeline(t,e){if(this.renderPipeline)return this.renderPipeline;const r=[];for(const i of this.vertexBufferLayout)r.push({arrayStride:i.stride,stepMode:this.vertexStepMode,attributes:Object.values(i.attributes)});return this.renderPipeline=t.createRenderPipeline({label:this.label,layout:"auto"===this.pipelineLayout?"auto":g.getPipelineLayout(t,this.pipelineLayout),vertex:{module:this.vertexShaderModule.getGPUShaderModule(t),entryPoint:this.vertexShaderEntryPoint,buffers:[...r]},fragment:{module:this.fragmentShaderModule.getGPUShaderModule(t),entryPoint:this.fragmentShaderEntryPoint,targets:e}})}}async function D(t){await async function(t){if(x.isInitialized)return;if(!navigator.gpu)throw new Error("WebGPU not supported");const e=await navigator.gpu.requestAdapter();if(null===e)throw new Error("WebGPU not supported");const r=await e.requestDevice();if(null===r)throw new Error("WebGPU not supported");const i=t.getContext("webgpu");if(null===i)throw new Error("WebGPU not supported");const s=navigator.gpu.getPreferredCanvasFormat();i.configure({device:r,format:s}),x.isInitialized=!0,x.adapterProxy.set(e),x.deviceProxy.set(r),x.contextProxy.set(i),x.preferredFormat=s,new ResizeObserver((()=>{t.width=t.clientWidth,t.height=t.clientHeight,i.configure({device:r,format:s}),t.dispatchEvent(new Event("resize"))})).observe(t),x.canvasProxy.set(t),t.width=t.clientWidth,t.height=t.clientHeight}(t)}export{g as B,G as D,l as M,O as P,C as S,c as V,f as a,p as b,R as c,k as d,m as e,N as f,F as g,Y as h,t as i,P as j,D as k,u as l,A as m,v as n,a as o,M as p,z as r,i as v};
